# 2021.09.04(토) TIL 8th

# 제로베이스 CSS강의

## 5-1. 박스 모델이란

복잡해 보이지만 사실 모두 박스의 집합이다. 

![box_model](https://user-images.githubusercontent.com/61327153/132096144-82ea7f5e-b9c4-4a8d-8e07-1c52cdbe9079.PNG)

- content : 콘텐츠가 표시되는 영영
- padding : 콘텐츠와 테두리(border) 사이의 영역
- border : padding과 margin 사이의 테두리
- margin : 가장 바깥쪽 레이어, 다른 모든 요소를 둘러싸면서 해당 box와 다른 box 사이의 공백 역할을 한다.

## 5-2. 크기 width, height

px, em, %, auto 등을 사용 가능함.

상속이 되지 않음 → 자식요소들에게 전파가 되지 않는다. 

inline에는 내용의 길이에 따라 길이를 가지므로 width, height를 줘도 적용이x

## 5-3. 크기 max-width, min-width, max-height, min-height

px, em, %, auto(디폴트 값) 등을 사용 가능함. IE 7 이상에서는 사용가능함. (함수 표기법인 min, max보다 이것을 사용하도록 권장)

최대, 최소의 너비,높이! (값의 범위를 정해준다) → min, max는 부모의 크기보다 커지거나 작아질 수 있다!(상속보다 우선적으로??)

## 5-4 여백 margin

```css
.margin {
  width: 100px;
  height: 100px;
  background-color: lightsalmon;
  margin: 10px; # 4방향 모두 적용
  margin: 5% auto; # 위아래, 좌우 적용
  margin: 5px auto 10px; # 위 좌우 아래
  margin: 5px 6px 7px 8px; # 위 오른쪽 아래 왼쪽(시계방향)
}
```

단 %를 사용 할 때는 부모의 margin이 아니라, 부모의 width의 %가 적용된다

## 5-5, 5-6 여백 margin collapsing1

margin끼리 겹칠 때 상쇄되는 경우

- 블록 요소가 하나or두개이상일때, margin이 위/아래에서 겹칠 때 (left, right에는 발생하지x, inline 에는 x)
1. 인접 형제
- 두 형제 요소의 위 아래 여백이 만나서 상쇄된다.
2. 부모-자식 요소 간
- 부모 블록에 border, padding, inlinecontent 가 없어서 부모와 자식의 margin-top 이 만나는 경우
- 부모 블록에 border, padding, inlinecontent 가 없고, 부모-자식 을 분리할 height 값이 지정되지 않아서 부모와 자식의 margin-bottom이 만나는 경우
3. 빈 블록
- border, padding, inlinecontent 가 없고, height 또한 존재하지 않는다면 해당 블록의 margin-top과 margin-bottom이 상쇄된다.

## 5-7. 여백 padding

border의 내부 여백. margin과 똑같이 shorthand로 사용가능(4가지 사용가능)

margin과 다르게 상쇄가 발생하지 않는다. 음수 값은 사용 할 수 없다.

%를 사용시에 주의하기(부모의 padding값을 상속받는게 아니다) → 부모의 width 의 % 를 적용받는다, 단 `padding-top` 도 부모의 width의 %를 받는거다(무 조 건! width)

## 5-8. 테두리 border-style, border-width, border-color

border-style : 테두리의 스타일 기본값은 `none` solid, dashed, dotted 등을 주로 사용(키워드로 작성) shorthand로 사용 가능(margin을 쓰는 것처럼 시계방향)

border-width : length 값 or thin, medium, thick 의 키워드도 사용가능

border-color : 컬러 value를 사용, shorthand사용 가능

 + style이 `none` 이라면 뒤에 아무리 뭘 추가해도 안보임

## 5-9. 테두리 border(shorthand)

border는 대부분 shorthand를 사용해서 작성.(단, 순서를 지키지 않아도 사용가능함 → 겹치는 값?같은게 없어서)

주의!!! style을 지정하지 않으면 `none` 이 되어버려서 안보이게 된다. → border로 쓰면 필수!

- 테두리 vs 외곽선(outline)
외곽선은 button등에 테두리가 생기는것(요소를 강조 용이지 layout에 들어가지 않음 → box model에 속해있지 않다.

## 5-10. 테두리 border-radius

테두리의 꼭짓점을 둥글게 만들어준다.

length 값을 사용가능함(px, %) 단, %를 사용시에 가로축은 요소 박스의 너비에 대한 백분율, 세로축은 박스의 높이에 대한 백분율(margin, padding과 다르게 세로도 포함)(타원형 꼭지점도 가능)

꼭 border과 함께 사용하지 않아도 된다.(아예 도형을 이렇게 만들기)
shorthand로 사용 가능(왼쪽 위부터 시계방향) → 꼭지점에 들어갈 원의 반지름이 이 값

```css
.box {
  width: 300px;
  height: 300px;
  border: 5px red solid;
  border-radius: 50px;
  background-color: skyblue;
}
```

## 5-11. box-sizing

요소의 너비와 높이를 계산하는 방법을 지정한다(???)  아래 두가지 중 하나로 지정 가능

- content-box(기본값)
- width, height가 콘텐츠의 영역만 포함해서 border, margin은 포함하지 않는다.
- border-box
-  width, height가 총 크기(border, margin를 포함한거)를 지정함 → 모자라면 내부가 줄어듬

    ```css
    .box {
      width: 300px; # content 의 너비
      height: 200px; # content 의 높이

      border: 30px solid blue;
      padding: 20px;
      background-color: skyblue;
    }
    content-box(기본값)이면 실제로는 가로가 300 + (20*2) + (30*2) = 400 이 된다.

    box-sizing: border-box; 를 추가하게 된다면
    -> 진짜 전체 요소의 width가 300px이 되게 한다.
    ```

    ---

    ## 6-1. display - inline, block, inline-block

    inline의 특징 : 영역의 크기가 내부 콘텐츠의 크기로 정해진다. margin, padding의 top,bottom을 지정할 수 없다(해도 반영x), 여러 요소가 가로배치가 된다. 

    block의 특징 : 영역의 크기를 width, height로 지정 가능, width를 지정하지 않으면 기본값은 가로 전체, 여러 요소가 세로 배치된다.

    inline-block : ex) input → 영역의 w, h 를 지정 가능 but 여러 요소가 가로로 배치된다.

    `display` 속성에 `block` `inline-block` 등으로 지정하면 그 특징을 갖게한다.(진짜 그 속성을 갖는것은 아님)

    ## 6-2. 요소를 없애는 방법 display none, visibility hidden

    결과는 같지만 차이점이 존재! → layout을 건드느냐의 차이

    display none 은 코드를 아예 없는 것 처럼 그 요소를 숨김(그만큼 다음 요소가 당겨짐?)

    visibility hidden 은 layout을 건들지 않고 그 요소만 숨김

    ## 6-3. float (떠다님)

    한 요소가 보통 흐름(normal flow)으로부터 빠져서 텍스트 또는 인라인 요소가 그 주위를 감싸는 자기 컨테이너의 좌우측을 따라서 배치되어야 한다고 지정

    `none` `left` `right` 를 사용가능(article이나 사진에서 사진을 띄우는거 처럼)

    현재는 flex-box가 등장해서 사용빈도가 낮아짐

    ```css
    .float {
      width: 100px;
      height: 100px;
      background-color: gray;
      border: 5px solid blue;
      float: left;
      margin: 10px;
    }
    이 다음 태그는 float 의 오른쪽에 배치된다
    ```

    ## 6-4. position과 Normal Flow

    position : 문서상에 요소를 배치 하는 방법(top right bottom 등)

    normal flow : 요소의 레이아웃을 변경하지 않았을 때, 웹페이지 요소가 자기 자신을 배치하는 방법(기본적인 자리배치) 기본값은 `static`

    ## 6-5. position - relative

    n***

    normal flow에 따라 배치하고, '자기 자신'을 기준으로 `top` `right` `bottom` `left` 의 값에 따라서 오프셋을 적용한다. 단, 오프셋은 다른 요소에 영향을 끼치지 않기 때문에 레이아웃이 차지하는 공간은 `static` 과 동일함.

    ```css
    #box {
      background-color: peachpuff;
      position: relative;
      top: 50px;
    	left: 30px;
    }
    # 내가 원래 있던 위치보다 50px 만큼 내려옴
    # 원래 위치보다 오른쪽으로 30px
    ```

    주의 !! top과 bottom을 동시에 or left, right를 동시에 선언하면 top과 left가 우선시된다.

    ```css
    #box {
      background-color: peachpuff;
      position: relative;
      bottom: 30px;
      top: 50px;
      left: 30px;
      right: 50px;
    }
    -> left와 top만 적용되고 right와 bottom은 무시
    ```

    ## 6-6. position - absolute

    normal flow에서 제거하고, 페이지 레이아웃에 공간도 배정하지 않는다. 대신에 가장 가까운 위치 지정조상요소(parent)에 대해서 상대적으로 배치한다.

    → 원래 따르던 흐름에서 나와서 붕~ 뜨게된다. (그래서 다음 요소가 위의 요소의 아래에 위치함)
    부모의 기준에 따라가면서 포지션이 static이 아닌(relative, absolute 등) 부모를 따라서 `top` `left` 등을 위치시킨다. 

    ## 6-7. position - fixed

    요소를 normal flow에서 제거하고, 페이지 레이아웃에 공간을 배정하지 않는다. 대신 viewport 의 초기 컨테이닝 블록을 기준으로 삼아서 배치한다. 단, 조상(parent)의 요소 중 하나가 `transform` `perspective` `filter` 중 하나라도 none 이 아니면 뷰포트 대신 그 조상을 컨테이너 블록으로 삼는다.

    → 기준점이 정해져있다(뷰포트의 초기 컨테이닝 블록)

    ```css
    #box {
      width: 150px;
      height: 150px;
      background-color: peachpuff;
      border-radius: 30px;

      position: fixed;
      top: 0px;
      left: 0px;
    }
    -> 스크롤을 해도 따라다님(뷰포트를 따라다니니까)
    -> 기준은 모두 뷰포트(안드로이드의 floating button 느낌)
    ```

    ## 6-8. position - sticky

    normal flow에 따라서 배치하고, table관련 요소를 포함해 가장 가까운 스크롤 되는 조상과 표관룔 요소를 포함한 컨테이닝 블록을 기준으로 한다. 오프셋은 다른 요소에 영향을 주지x

    ```css
    #parent {
      position: sticky;
      top: 100px;
      left: 100px;
    }
    원래 자기 위치에 있다가 스크롤을 이동하다가 들어가면 fixed처럼 도착
    스티커처럼! -> 블로그에서 내릴수록 소제목을 계속 쌓아가는 식

    ```

    ## 6-9. overflow

    요소의 컨텐츠가 너무 커서 요소의 블록 서식 맥락에 맞출 수 없을 때의 처리법을 지정함. `overflow-x` `overflow-y` 값을 설정

    container의 크기보다 내용물의 크기가 크다면 어떻게 처리할지 → shorthand로 쓸 수 있음

    `visible` : 넘치는걸 다 보도록(넘친상태로)
    `hidden` : 숨김
    `scroll` : 마우스를 올리고 스크롤하면 보이도록(기본적으로 스크롤 바가 생성된다)
    `auto` : 자동 → 넘치지 않으면 visible, 넘치면 scroll로 사용된다(제일 편한듯)

    ## 6-10. z-index

    z축의 순서를 지정한다(z축은 깊이?라고 생각 할 수있다, 겹쳤을 때 뭐가 위에 나타날지)

    0,양,음의 정수를 사용가능. 큰 값이 더 앞에 나옴(나머지를 덮음)

    `z-index: auto`로 하게되면 코드의 순서대로 쌓이고, `position`이 `static`이 아닌 애가 `static`보다 더 앞에 나옴(static을 덮어쓴다)